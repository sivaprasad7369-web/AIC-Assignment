"""
This type stub file was generated by pyright.
"""

import sqlite3
from owlready2.base import *
from owlready2.driver import BaseMainGraph, BaseSubGraph
from owlready2.util import _LazyListMixin

if (sqlite3.sqlite_version == "3.40.0") or (sqlite3.sqlite_version == "3.41.2"):
  ...
def all_combinations(l): # -> tuple[()] | list[tuple[Any]] | list[Any]:
  """returns all the combinations of the sublist in the given list (i.e. l[0] x l[1] x ... x l[n])."""
  ...

class _Connexion:
  def __init__(self, pool, uri) -> None:
    ...
  
  def __enter__(self): # -> Self:
    ...
  
  def __exit__(self, exc_type=..., exc_val=..., exc_tb=...): # -> None:
    ...
  


class _ConnexionPool:
  def __init__(self, uri, nb_connexion=...) -> None:
    ...
  


class Graph(BaseMainGraph):
  _SUPPORT_CLONING = ...
  def __init__(self, filename, clone=..., exclusive=..., sqlite_tmp_dir=..., world=..., profiling=..., read_only=..., enable_thread_parallelism=..., lock=..., extra_lock=..., connection=..., journal_mode=...) -> None:
    ...
  
  def __del__(self): # -> None:
    ...
  
  def get_wal_mode(self): # -> Any | Literal[False]:
    ...
  
  def set_wal_mode(self, mode): # -> None:
    ...
  
  def analyze(self): # -> None:
    ...
  
  def set_indexed(self, indexed): # -> None:
    ...
  
  def close(self): # -> None:
    ...
  
  def acquire_write_lock(self): # -> None:
    ...
  
  def release_write_lock(self): # -> None:
    ...
  
  def has_write_lock(self): # -> int:
    ...
  
  def select_abbreviate_method(self): # -> None:
    ...
  
  def fix_base_iri(self, base_iri, c=...):
    ...
  
  def sub_graph(self, onto): # -> tuple[SubGraph, bool]:
    ...
  
  def ontologies_iris(self): # -> Generator[Any, Any, None]:
    ...
  
  def get_storid_dict(self): # -> dict[Any, Any]:
    ...
  
  def has_changes(self): # -> bool:
    ...
  
  def commit(self): # -> None:
    ...
  
  def context_2_user_context(self, c):
    ...
  
  def new_blank_node(self): # -> Any:
    ...
  
  def __bool__(self): # -> Literal[True]:
    ...
  
  def __len__(self): # -> Any:
    ...
  
  def restore_iri(self, storid, iri): # -> None:
    ...
  
  def destroy_entity(self, storid, destroyer, relation_updater, undoer_objs=..., undoer_datas=...): # -> set[Any]:
    ...
  
  def get_fts_prop_storid(self): # -> set[Any]:
    ...
  
  def enable_full_text_search(self, prop_storid): # -> None:
    ...
  
  def disable_full_text_search(self, prop_storid): # -> None:
    ...
  


class SubGraph(BaseSubGraph):
  def __init__(self, parent, onto, c, db) -> None:
    ...
  
  def import_triples_from_queue(self, queue, filename=..., delete_existing_triples=...): # -> tuple[Callable[..., None], Callable[..., None], Callable[[], Any | Literal['']]] | Literal['']:
    ...
  
  def create_parse_func(self, filename=..., delete_existing_triples=..., datatype_attr=...): # -> tuple[list[Any], list[Any], Callable[..., None], Callable[..., None], Callable[[], None], Callable[[], None], Any, Callable[..., Any], Callable[[], Any | Literal['']]]:
    ...
  
  def context_2_user_context(self, c):
    ...
  
  def add_ontology_alias(self, iri, alias): # -> None:
    ...
  
  def get_last_update_time(self):
    ...
  
  def set_last_update_time(self, t): # -> None:
    ...
  
  def destroy(self): # -> None:
    ...
  
  def search(self, prop_vals, c=..., debug=...):
    ...
  
  def __len__(self):
    ...
  


class _SearchMixin(list):
  __slots__ = ...
  def sql_request(self): # -> tuple[str | Any, Any]:
    ...
  
  _get_content = ...
  def first(self): # -> None:
    ...
  
  def has_bm25(self): # -> Literal[False]:
    ...
  
  def __len__(self):
    ...
  


class _PopulatedSearchList(FirstList):
  __slots__ = ...
  def has_bm25(self):
    ...
  


_NEXT_SEARCH_ID = ...
class _SearchList(FirstList, _SearchMixin, _LazyListMixin):
  __slots__ = ...
  _PopulatedClass = _PopulatedSearchList
  def has_bm25(self): # -> bool:
    ...
  
  def __init__(self, world, prop_vals, c=..., case_sensitive=..., bm25=...) -> None:
    ...
  
  def sql_components(self, last_request=...): # -> tuple[list[Any], LiteralString | str, list[Any]]:
    ...
  
  def __or__(self, other): # -> _UnionSearchList:
    ...
  
  def __and__(self, other): # -> _IntersectionSearchList:
    ...
  
  def dump(self): # -> None:
    ...
  


class _PopulatedUnionSearchList(FirstList):
  __slots__ = ...


class _UnionSearchList(FirstList, _SearchMixin, _LazyListMixin):
  __slots__ = ...
  _PopulatedClass = _PopulatedUnionSearchList
  def has_bm25(self): # -> bool:
    ...
  
  nested_searchs = ...
  def __init__(self, world, searches) -> None:
    ...
  
  def sql_components(self, last_request=...): # -> tuple[list[Any], LiteralString, list[Any]]:
    ...
  
  def __or__(self, other): # -> _UnionSearchList:
    ...
  
  def dump(self): # -> None:
    ...
  
  def explode(self, gen): # -> tuple[Any, ...]:
    ...
  


class _PopulatedIntersectionSearchList(FirstList):
  __slots__ = ...


class _IntersectionSearchList(FirstList, _SearchMixin, _LazyListMixin):
  __slots__ = ...
  _PopulatedClass = _PopulatedIntersectionSearchList
  def has_bm25(self): # -> bool:
    ...
  
  nested_searchs = ...
  def __init__(self, world, searches) -> None:
    ...
  
  def sql_components(self, last_request=...): # -> tuple[list[Any], LiteralString, list[Any]]:
    ...
  
  def __and__(self, other): # -> _IntersectionSearchList:
    ...
  
  def dump(self): # -> None:
    ...
  
  def explode(self, gen):
    ...
  
  _get_content = ...
  def __len__(self): # -> int:
    ...
  


