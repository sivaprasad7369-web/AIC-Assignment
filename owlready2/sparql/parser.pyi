"""
This type stub file was generated by pyright.
"""

from owlready2 import *

lg = ...
LEXER = ...
pg = ...
@pg.production("main : prefix_decl* select_query")
def f(p):
  ...

@pg.production("main : prefix_decl* modify")
def f(p):
  ...

@pg.production("prefix_decl : PREFIX PNAME_NS unabbreviated_iri")
def f(p): # -> None:
  ...

@pg.production("prefix_decl : BASE iri")
def f(p): # -> None:
  ...

@pg.production("select_query : SELECT distinct_reduced? select_clause_part+ WHERE? group_graph_pattern solution_modifier")
@pg.production("select_query : SELECT distinct_reduced? * WHERE? group_graph_pattern solution_modifier")
def f(p):
  ...

@pg.production("distinct_reduced? : DISTINCT")
@pg.production("distinct_reduced? : REDUCED")
def f(p):
  ...

@pg.production("distinct_reduced? : ")
def f(p): # -> None:
  ...

@pg.production("select_clause_part : var")
def f(p):
  ...

@pg.production("select_clause_part : ( expression AS var )")
def f(p):
  ...

@pg.production("dataset_clause : FROM iri")
@pg.production("dataset_clause : FROM NAMED iri")
def f(p):
  ...

@pg.production("solution_modifier : group_clause? having_clause? order_clause? limit_offset_clauses?")
def f(p): # -> list[Any]:
  ...

@pg.production("group_clause : GROUP_BY group_condition+")
def f(p):
  ...

@pg.production("group_condition : builtin_call")
@pg.production("group_condition : function_call")
@pg.production("group_condition : var")
@pg.production("group_condition : expression")
@pg.production("group_condition : expression AS var")
def f(p):
  ...

@pg.production("having_clause : HAVING constraint+")
def f(p):
  ...

@pg.production("order_clause : ORDER_BY order_condition+")
def f(p):
  ...

@pg.production("order_condition : ASC bracketted_expression")
@pg.production("order_condition : DESC bracketted_expression")
@pg.production("order_condition : constraint")
@pg.production("order_condition : var")
def f(p):
  ...

@pg.production("limit_offset_clauses : limit_clause")
def f(p): # -> list[Any]:
  ...

@pg.production("limit_offset_clauses : offset_clause")
def f(p): # -> list[Any]:
  ...

@pg.production("limit_offset_clauses : limit_clause offset_clause")
def f(p):
  ...

@pg.production("limit_offset_clauses : offset_clause limit_clause")
def f(p): # -> list[Any]:
  ...

@pg.production("limit_clause : LIMIT INTEGER")
@pg.production("limit_clause : LIMIT param")
def f(p):
  ...

@pg.production("offset_clause : OFFSET INTEGER")
@pg.production("offset_clause : OFFSET param")
def f(p):
  ...

@pg.production("with_iri : WITH IRI")
def f(p):
  ...

@pg.production("modify : with_iri? insert_clause using_clause*  WHERE group_graph_pattern solution_modifier")
def f(p):
  ...

@pg.production("modify : with_iri? delete_clause using_clause*  WHERE group_graph_pattern solution_modifier")
def f(p):
  ...

@pg.production("modify : with_iri? delete_clause insert_clause using_clause*  WHERE group_graph_pattern solution_modifier")
def f(p):
  ...

@pg.production("graph_or_triples_same_subject_path : triples_same_subject_path")
def f(p): # -> list[list[tuple[None, *tuple[Any, ...]]]]:
  ...

@pg.production("graph_or_triples_same_subject_path : GRAPH iri { triples_same_subject_path+ }")
def f(p): # -> list[list[tuple[Token, *tuple[Any, ...]]]]:
  ...

@pg.production("graph_or_triples_same_subject_path : GRAPH var { triples_same_subject_path+ }")
def f(p): # -> list[list[tuple[Any, *tuple[Any, ...]]]]:
  ...

@pg.production("delete_clause : DELETE { triples_same_subject_path+ }")
def f(p): # -> list[Any]:
  ...

@pg.production("insert_clause : INSERT { graph_or_triples_same_subject_path+ }")
def f(p): # -> list[Any]:
  ...

@pg.production("using_clause : USING iri")
@pg.production("using_clause : USING NAMED iri")
def f(p):
  ...

@pg.production("group_graph_pattern : { select_query }")
def f(p): # -> SubQueryBlock:
  ...

@pg.production("group_graph_pattern_item : triples_same_subject_path")
def f(p):
  ...

@pg.production("group_graph_pattern_item : group_graph_pattern+")
def f(p): # -> Block | UnionBlock:
  ...

@pg.production("group_graph_pattern_item : OPTIONAL group_graph_pattern")
def f(p): # -> list[Any] | OptionalBlock:
  ...

@pg.production("group_graph_pattern_item : MINUS group_graph_pattern")
def f(p): # -> MinusBlock:
  ...

@pg.production("group_graph_pattern_item : FILTER constraint")
def f(p): # -> ExistsBlock | NotExistsBlock | Filter:
  ...

@pg.production("group_graph_pattern_item : BIND ( expression AS var )")
def f(p): # -> Bind:
  ...

@pg.production("group_graph_pattern_item : inline_data")
def f(p):
  ...

@pg.production("group_graph_pattern_item : STATIC group_graph_pattern")
def f(p): # -> StaticBlock:
  ...

@pg.production("group_graph_pattern_item : GRAPH iri group_graph_pattern")
def f(p):
  ...

@pg.production("group_graph_pattern_item : GRAPH var group_graph_pattern")
@pg.production("group_graph_pattern_item : GRAPH param group_graph_pattern")
def f(p):
  ...

@pg.production("inline_data : VALUES data_block")
def f(p):
  ...

@pg.production("data_block : inline_data_one_var")
@pg.production("data_block : inline_data_full")
def f(p):
  ...

@pg.production("inline_data_one_var : var { data_block_value* }")
def f(p): # -> StaticValues:
  ...

@pg.production("data_block_values : ( data_block_value* )")
def f(p):
  ...

@pg.production("inline_data_full : ( var* ) { data_block_values* }")
def f(p): # -> StaticValues:
  ...

@pg.production("data_block_value : iri")
@pg.production("data_block_value : rdf_literal")
@pg.production("data_block_value : numeric_literal")
@pg.production("data_block_value : undef")
def f(p):
  ...

@pg.production("data_block_value : BOOL")
def f(p):
  ...

@pg.production("constraint : bracketted_expression")
@pg.production("constraint : builtin_call")
@pg.production("constraint : function_call")
def f(p):
  ...

@pg.production("function_call : iri arg_list")
def f(p):
  ...

@pg.production("arg_list : NIL")
@pg.production("arg_list : ( DISTINCT? expression+ )")
@pg.production("expression_list : NIL")
@pg.production("expression_list : ( expression+ )")
def f(p):
  ...

@pg.production("property_list_not_empty_part : var_or_iri object+")
def f(p):
  ...

@pg.production("property_list_not_empty : property_list_not_empty_part+ ")
def f(p):
  ...

@pg.production("triples_same_subject_path : var_or_term property_list_path_not_empty")
@pg.production("triples_same_subject_path : triples_node_path property_list_path_not_empty?")
def f(p): # -> list[Any]:
  ...

@pg.production("property_list_path_not_empty_part : path object_path+")
@pg.production("property_list_path_not_empty_part : var object_path+")
def f(p):
  ...

@pg.production("property_list_path_not_empty : property_list_path_not_empty_part+")
def f(p): # -> list[list[Any]]:
  ...

@pg.production("path : path_sequence+")
def f(p): # -> UnionPropPath:
  ...

@pg.production("path_sequence : path_element_or_inverse+")
def f(p): # -> SequencePropPath:
  ...

@pg.production("path_element_or_inverse : path_element")
def f(p):
  ...

@pg.production("path_element_or_inverse : ^ path_element")
def f(p):
  ...

@pg.production("path_element : path_primary path_mod?")
def f(p):
  ...

@pg.production("path_mod : ?")
@pg.production("path_mod : *STATIC")
@pg.production("path_mod : *")
@pg.production("path_mod : +")
def f(p):
  ...

@pg.production("path_primary : iri")
@pg.production("path_primary : param")
def f(p):
  ...

@pg.production("path_primary : ! path_negated_property_set")
def f(p): # -> NegatedPropPath:
  ...

@pg.production("path_primary : ( path )")
def f(p):
  ...

@pg.production("path_negated_property_set : path_one_in_property_set")
def f(p):
  ...

@pg.production("path_negated_property_set : ( path_one_in_property_set+ )")
def f(p):
  ...

@pg.production("path_one_in_property_set : iri")
def f(p):
  ...

@pg.production("path_one_in_property_set : ^ iri")
def f(p):
  ...

@pg.production("triples_node : collection")
@pg.production("triples_node : blank_node_property_list")
def f(p):
  ...

@pg.production("blank_node_property_list : [ property_list_not_empty ]")
def f(p):
  ...

@pg.production("triples_node_path : collection_path")
def f(p):
  ...

@pg.production("triples_node_path : [ property_list_path_not_empty ]")
def f(p):
  ...

@pg.production("collection : ( graph_node+ )")
@pg.production("collection_path : ( graph_node_path+ )")
def f(p):
  ...

@pg.production("object_path : graph_node_path")
def f(p):
  ...

@pg.production("object : graph_node")
def f(p):
  ...

@pg.production("graph_node : var")
@pg.production("graph_node : graph_term")
@pg.production("graph_node : triples_node")
def f(p):
  ...

@pg.production("graph_node_path : var")
@pg.production("graph_node_path : graph_term")
@pg.production("graph_node_path : triples_node_path")
def f(p):
  ...

@pg.production("var_or_term : var")
@pg.production("var_or_term : graph_term")
@pg.production("var_or_iri : var")
@pg.production("var_or_iri : iri")
def f(p):
  ...

@pg.production("var : VAR")
def f(p):
  ...

@pg.production("graph_term : iri")
@pg.production("graph_term : rdf_literal")
@pg.production("graph_term : numeric_literal")
@pg.production("graph_term : blank_node")
@pg.production("graph_term : NIL")
@pg.production("graph_term : param")
def f(p):
  ...

@pg.production("graph_term : BOOL")
def f(p):
  ...

@pg.production("param : PARAM")
def f(p):
  ...

@pg.production("conditional_or_expression_operand : || conditional_and_expression")
def f(p):
  ...

@pg.production("expression : conditional_and_expression conditional_or_expression_operand*")
def f(p):
  ...

@pg.production("conditional_and_expression_operand : && relational_expression")
def f(p):
  ...

@pg.production("conditional_and_expression : relational_expression conditional_and_expression_operand*")
def f(p):
  ...

@pg.production("comparator : =")
@pg.production("comparator : COMPARATOR")
def f(p):
  ...

@pg.production("relational_expression : numeric_expression")
@pg.production("relational_expression : numeric_expression comparator numeric_expression")
@pg.production("relational_expression : numeric_expression LIST_COMPARATOR expression_list")
def f(p):
  ...

@pg.production("relational_expression : numeric_expression LIST_COMPARATOR param")
def f(p):
  ...

@pg.production("numeric_expression_operand : + multiplicative_expression")
@pg.production("numeric_expression_operand : - multiplicative_expression")
def f(p): # -> list[Any]:
  ...

@pg.production("numeric_expression : multiplicative_expression numeric_expression_operand*")
def f(p): # -> list[Any]:
  ...

@pg.production("multiplicative_expression_operand : * unary_expression")
@pg.production("multiplicative_expression_operand : / unary_expression")
def f(p): # -> list[Any]:
  ...

@pg.production("multiplicative_expression : unary_expression multiplicative_expression_operand*")
def f(p): # -> list[Any]:
  ...

@pg.production("unary_expression : ! primary_expression")
def f(p):
  ...

@pg.production("unary_expression : + primary_expression")
@pg.production("unary_expression : - primary_expression")
@pg.production("unary_expression : primary_expression")
def f(p):
  ...

@pg.production("primary_expression : bracketted_expression")
@pg.production("primary_expression : builtin_call")
@pg.production("primary_expression : iri_or_function")
@pg.production("primary_expression : rdf_literal")
@pg.production("primary_expression : numeric_literal")
@pg.production("primary_expression : var")
@pg.production("primary_expression : param")
def f(p):
  ...

@pg.production("primary_expression : BOOL")
def f(p):
  ...

@pg.production("bracketted_expression : ( expression )")
def f(p):
  ...

@pg.production("builtin_call : func")
@pg.production("builtin_call : aggregate")
@pg.production("builtin_call : exists")
@pg.production("builtin_call : not_exists")
@pg.production("builtin_call : aggregate")
def f(p):
  ...

@pg.production("func : iri ( expression* )")
def f(p):
  ...

@pg.production("func : FUNC ( expression* )")
@pg.production("func : FUNC NIL")
def f(p):
  ...

@pg.production("aggregate : AGGREGATE_FUNC ( DISTINCT? * )")
@pg.production("aggregate : AGGREGATE_FUNC ( DISTINCT? expression )")
@pg.production("aggregate : AGGREGATE_FUNC ( DISTINCT? expression ; SEPARATOR = string )")
def f(p):
  ...

@pg.production("aggregate : AGGREGATE_FUNC ( DISTINCT? expression ; SEPARATOR = string ORDER_BY expression )")
def f(p):
  ...

@pg.production("aggregate : AGGREGATE_FUNC ( DISTINCT? expression ORDER_BY expression )")
def f(p):
  ...

@pg.production("exists : EXISTS group_graph_pattern")
@pg.production("not_exists : NOT_EXISTS group_graph_pattern")
def f(p):
  ...

@pg.production("iri_or_function : iri arg_list?")
def f(p):
  ...

@pg.production("rdf_literal : string")
def f(p):
  ...

@pg.production("rdf_literal : string LANG_TAG")
def f(p):
  ...

@pg.production("rdf_literal : string ^^ iri")
def f(p):
  ...

_INT_DATATYPES = ...
_FLOAT_DATATYPES = ...
@pg.production("numeric_literal : INTEGER")
def f(p):
  ...

@pg.production("numeric_literal : DECIMAL")
@pg.production("numeric_literal : DOUBLE")
def f(p):
  ...

@pg.production("string : STRING_LITERAL1")
def f(p):
  ...

@pg.production("string : STRING_LITERAL2")
def f(p):
  ...

@pg.production("string : STRING_LITERAL_LONG1")
@pg.production("string : STRING_LITERAL_LONG2")
def f(p):
  ...

@pg.production("unabbreviated_iri : IRI")
def f(p):
  ...

@pg.production("iri : IRI")
def f(p):
  ...

@pg.production("iri : PREFIXED_NAME")
def f(p):
  ...

@pg.production("iri : PNAME_NS")
def f(p):
  ...

@pg.production("iri : A")
def f(p):
  ...

@pg.production("blank_node : BLANK_NODE_LABEL")
def f(p):
  ...

@pg.production("blank_node : ANON")
def f(p):
  ...

@pg.production("undef : UNDEF")
def f(p):
  ...

PARSER = ...
CURRENT_TRANSLATOR = ...
_DATA_TYPE = ...
_OBJ_PROPS = ...
_DATA_PROPS = ...
class Block(list):
  ontology = ...
  def __repr__(self): # -> str:
    ...
  
  def get_ordered_vars(self): # -> list[Any]:
    ...
  
  def __hash__(self) -> int:
    ...
  


class UnionBlock(Block):
  def __init__(self, l=...) -> None:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class TripleBlock(Block):
  def __init__(self, l=...) -> None:
    ...
  


class TripleBlockWithStatic(TripleBlock):
  def __init__(self, l=...) -> None:
    ...
  


class SimpleTripleBlock(TripleBlockWithStatic):
  def get_ordered_vars(self): # -> list[Any]:
    ...
  


class OptionalBlock(TripleBlock):
  ...


class FilterBlock(TripleBlockWithStatic):
  ...


class ExistsBlock(FilterBlock):
  ...


class NotExistsBlock(FilterBlock):
  ...


class MinusBlock(TripleBlock):
  ...


class SubQueryBlock(Block):
  def parse(self):
    ...
  


class Triple(tuple):
  end_sequence = ...
  def __init__(self, l) -> None:
    ...
  


class SpecialCondition:
  ...


class SimpleUnion(SpecialCondition):
  name = ...
  modifier = ...
  inversed = ...
  def __init__(self, items) -> None:
    ...
  
  def create_conditions(self, conditions, table, n): # -> None:
    ...
  
  def __repr__(self): # -> LiteralString:
    ...
  
  def __str__(self) -> str:
    ...
  


class PropPath(list):
  def __init__(self, l=...) -> None:
    ...
  
  __hash__ = ...


class NegatedPropPath(PropPath, SpecialCondition):
  name = ...
  def create_conditions(self, conditions, table, n): # -> None:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class SequencePropPath(PropPath):
  name = ...
  def __repr__(self): # -> str:
    ...
  


class UnionPropPath(PropPath):
  name = ...
  def __repr__(self): # -> str:
    ...
  


class Bind:
  def __init__(self, expression, var) -> None:
    ...
  


class Filter:
  def __init__(self, constraint) -> None:
    ...
  


class StaticValues:
  def __init__(self) -> None:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class StaticBlock(StaticValues):
  def __init__(self, blocks) -> None:
    ...
  
  def __repr__(self): # -> str:
    ...
  


